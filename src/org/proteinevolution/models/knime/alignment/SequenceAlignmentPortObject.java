package org.proteinevolution.models.knime.alignment;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.util.zip.ZipEntry;

import javax.swing.JComponent;

import org.knime.core.data.DataCell;
import org.knime.core.data.DataType;
import org.knime.core.data.image.ImageContent;
import org.knime.core.data.image.png.PNGImageContent;
import org.knime.core.node.CanceledExecutionException;
import org.knime.core.node.ExecutionMonitor;
import org.knime.core.node.port.AbstractPortObject;
import org.knime.core.node.port.PortObjectSpec;
import org.knime.core.node.port.PortObjectZipInputStream;
import org.knime.core.node.port.PortObjectZipOutputStream;
import org.knime.core.node.port.PortType;
import org.knime.core.node.port.PortTypeRegistry;
import org.knime.core.node.port.image.ImagePortObjectSpec;

public class SequenceAlignmentPortObject extends AbstractPortObject {

	public static final class Serializer extends AbstractPortObjectSerializer<SequenceAlignmentPortObject> {}
	
    /** Convenience accessor for the port type. */
    public static final PortType TYPE = PortTypeRegistry.getInstance().getPortType(SequenceAlignmentPortObject.class);
	
    
    private SequenceAlignment m_content;
    
    private SequenceAlignmentPortObjectSpec m_spec;
    
    
    
    /** Empty framework constructor. <b>Do not use!</b> */
    public SequenceAlignmentPortObject() {
        // no op
    }
    
    
    /**
     * Create new port object based on the given arguments. The cell class that
     * is generated by the {@link ImageContent#toImageCell()} method must be
     * compatible to all DataValue of the spec's
     * {@link ImagePortObjectSpec#getDataType()} return value.
     *
     * @param content The SequenceAlignment Object
     * @param spec The spec.
     * @throws NullPointerException If either argument is null.
     */
    public SequenceAlignmentPortObject(
    		final SequenceAlignment content,
            final SequenceAlignmentPortObjectSpec spec) {
    	
        if (spec == null || content == null) {
            throw new NullPointerException("Argument must not be null.");
        }
        
        this.m_content = content;
        this.m_spec = spec;    
    }
    

	@Override
	public String getSummary() {
				
		return "Number of sequences: " + this.m_content.getNumberOfSequences() + "\nLength: " + this.m_content.getLength();
	}

	@Override
	public PortObjectSpec getSpec() {
		
		return this.m_spec;
	}

	@Override
	public JComponent[] getViews() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void save(PortObjectZipOutputStream out, ExecutionMonitor exec)
			throws IOException, CanceledExecutionException {
		
		
		
	}

	@Override
	protected void load(
			final PortObjectZipInputStream in,
			final PortObjectSpec spec,
			final ExecutionMonitor exec) throws IOException, CanceledExecutionException {

	    ZipEntry nextEntry = in.getNextEntry();
	    String contentClName = nextEntry.getName();

	    Class<SequenceAlignment> contentCl;
	    try {
	        contentCl = (Class<SequenceAlignment>) Class.forName(contentClName);
	        
	    } catch (ClassNotFoundException ex) {
	        throw new IOException("Error converting to SequenceAlignment Class", ex);
	    }
	    
	    Constructor<SequenceAlignment> cons;
	    try {
	        cons = contentCl.getConstructor(InputStream.class);
	    } catch (Exception ex) {
	        throw new IOException("SequenceAlignment class '" + contentClName + "' "
	                + "is missing a required constructor, see javadoc", ex);
	    }

	    try {
	        m_content = cons.newInstance(in);
	    } catch (Exception ex) {
	        throw new IOException("Could not create an instance of '"
	                + contentClName + "'", ex);
	    }
	    in.close();
	    m_spec = (ImagePortObjectSpec)spec;
		
	}
}














