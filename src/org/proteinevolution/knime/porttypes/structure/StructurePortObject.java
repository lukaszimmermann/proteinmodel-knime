package org.proteinevolution.knime.porttypes.structure;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.zip.ZipEntry;

import javax.swing.JComponent;
import javax.swing.JList;
import javax.swing.JMenuBar;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.knime.core.data.image.ImageContent;
import org.knime.core.node.CanceledExecutionException;
import org.knime.core.node.ExecutionMonitor;
import org.knime.core.node.port.AbstractPortObject;
import org.knime.core.node.port.PortObjectSpec;
import org.knime.core.node.port.PortObjectZipInputStream;
import org.knime.core.node.port.PortObjectZipOutputStream;
import org.knime.core.node.port.PortType;
import org.knime.core.node.port.PortTypeRegistry;
import org.knime.core.node.port.image.ImagePortObjectSpec;
import org.proteinevolution.knime.porttypes.structure.view.JmolPanel;

public class StructurePortObject extends AbstractPortObject {

	public static final class Serializer extends AbstractPortObjectSerializer<StructurePortObject> {}
	
    /** Convenience accessor for the port type. */
    public static final PortType TYPE = PortTypeRegistry.getInstance().getPortType(StructurePortObject.class);
	
    private StructureContent m_content;
    
    private StructurePortObjectSpec m_spec;
    
    /** Empty framework constructor. <b>Do not use!</b> */
    public StructurePortObject() {
    	    	
        // no op
    }
  
    
    /**
     * Create new port object based on the given arguments. The cell class that
     * is generated by the {@link ImageContent#toImageCell()} method must be
     * compatible to all DataValue of the spec's
     * {@link ImagePortObjectSpec#getDataType()} return value.
     *
     * @param content The SequenceAlignment Object
     * @param spec The spec.
     * @throws NullPointerException If either argument is null.
     */
    public StructurePortObject(
    		final StructureContent content,
            final StructurePortObjectSpec spec) {
    	
        if (spec == null || content == null) {
            throw new NullPointerException("Argument must not be null.");
        }
        
        this.m_content = content;
        this.m_spec = spec;    
    }
    
    
    public StructureContent getStructure() {
        	
    	return this.m_content;
    }


	@Override
	public String getSummary() {
				
		return "TODO";
	}

	@Override
	public PortObjectSpec getSpec() {
		
		return this.m_spec;
	}

	@Override
	public JComponent[] getViews() {
				
		JmolPanel jmolPanel = new JmolPanel();
		jmolPanel.getViewer().openStringInline(this.m_content.getPdbString(0));
		
		JPanel main = new JPanel();
		main.setLayout(new BorderLayout());
	
		Integer[] labels = new Integer[this.m_content.getNoStructures()];
		
		for(int i = 0; i < labels.length; ++i) {
			
			labels[i] = i;
		}
		JList<Integer> recordSelector = new JList<>(labels);
		recordSelector.setPreferredSize(new Dimension(200, 2000));
		recordSelector.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		
		recordSelector.addListSelectionListener(new ListSelectionListener() {
			
			@Override
			public void valueChanged(ListSelectionEvent e) {
				
				jmolPanel.getViewer().openStringInline(
						StructurePortObject.this.m_content.getPdbString(recordSelector.getSelectedValue()));
				
			}
		});
		
		JMenuBar toolbar = new JMenuBar();
		toolbar.add(recordSelector);
		main.add(toolbar, BorderLayout.WEST);
		main.add(jmolPanel);
		
		return new JComponent[] {
				main
		};
	}

    /** {@inheritDoc} */
    @Override
    protected void save(
    		final PortObjectZipOutputStream out,
            final ExecutionMonitor exec) throws IOException,
            CanceledExecutionException {
           
        out.putNextEntry(new ZipEntry(m_content.getClass().getName()));  
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutput objectOut = new ObjectOutputStream(bos);
        objectOut.writeObject(this.m_content);
        objectOut.flush();
        out.write(bos.toByteArray());
        bos.close();
        out.close();
        objectOut.close();
    }

	@Override
	protected void load(
			final PortObjectZipInputStream in,
			final PortObjectSpec spec,
			final ExecutionMonitor exec) throws IOException, CanceledExecutionException {

	    ZipEntry nextEntry = in.getNextEntry();
	    String contentClName = nextEntry.getName();

	    Class<StructureContent> contentCl;
	    try {
	        contentCl = (Class<StructureContent>) Class.forName(contentClName);
	        
	    } catch (ClassNotFoundException ex) {
	        throw new IOException("Error converting to HHsuiteDB Class", ex);
	    }
	    
	    Constructor<StructureContent> cons;
	    try {
	        cons = contentCl.getConstructor(InputStream.class);
	    } catch (Exception ex) {
	        throw new IOException("SequenceAlignment class '" + contentClName + "' "
	                + "is missing a required constructor, see javadoc", ex);
	    }

	    try {
	        this.m_content = cons.newInstance(in);
	    } catch (Exception ex) {
	        throw new IOException("Could not create an instance of '"
	                + contentClName + "'", ex);
	    }
	    in.close();
	    this.m_spec = (StructurePortObjectSpec) spec;
	  
	}
}

